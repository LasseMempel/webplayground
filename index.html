<!DOCTYPE html>
<html>
    <head>
        <script src="js/d3.v7.min.js"></script>
        <link rel="icon" type="image/x-icon" href="files/CoffeeAndConservationLogo2.png">
    </head>
    <body>
        <form id="fileForm">
            <input type="file" id="fileInput">
            <button type="submit">Datei laden</button>
        </form>
        <div id="result"></div>
        <div id="testing"></div>
    </body>
    <script>
        const fileForm = document.getElementById('fileForm');
        fileForm.addEventListener('submit', inputFileTest);
        function inputFileTest() {
            event.preventDefault();
            const input = document.getElementById('fileInput');
            const file = input.files[0];
            // red content of file
            reader = new FileReader();
            reader.onload = function(e) {
                const result = e.target.result
                parseJsonld(result)// e.target.result should contain the text
            };
            const text = reader.readAsText(file);
        }
        function parseJsonld(file) {
            const data = {nodes: [], links: []};
            const jsonld = JSON.parse(file);
            for (const object of jsonld) {
                let node = {};
                if (object["@type"] == ["http://www.w3.org/2002/07/owl#Class"]) {
                    node.id = stripOwlPrefix(object["@id"]);
                    node.group = 1;
                    if (object["http://www.w3.org/2000/01/rdf-schema#subClassOf"]) {
                        let link = {}
                        link.source = stripOwlPrefix(object["@id"]);
                        for (const target of object["http://www.w3.org/2000/01/rdf-schema#subClassOf"]) {
                            link.target = stripOwlPrefix(target["@id"]);
                            link.value = 1;
                            link.name = "subClassOf"
                            data.links.push(link);
                        }
                    }
                }
                if (object["@type"] == ["http://www.w3.org/2002/07/owl#ObjectProperty"]) {
                    node.id = stripOwlPrefix(object["@id"]);
                    for (const domain in object["http://www.w3.org/2000/01/rdf-schema#domain"]) {
                        domain.id = stripOwlPrefix(domain["@id"]);
                        for (const range in object["http://www.w3.org/2000/01/rdf-schema#range"]) {
                            range.id = stripOwlPrefix(range["@id"]);
                            let link = {};
                            link.source = domain.id;
                            link.target = range.id;
                            link.value = 1;
                            link.name = node.id;
                            data.links.push(link);
                        }
                    }
                }
            }
            const result = document.getElementById('result');
            result.innerHTML = '';
            result.appendChild(generateGraph(data));
            const testing = document.getElementById('testing');
            result.innerHTML=data
        }

        /*
        function findOrCreateElementProperty(object, element, propertyKey, propertyValue) {
            if (object[element]) {
                object[element][propertyKey] = propertyValue;
                return object;
            } else {
                object[element] = {};
                object[element][propertyKey] = propertyValue;
                return object;
        }
        */

        function stripOwlPrefix(string) {
            return string.split("#")[-1];
        }
        function generateGraph(data) {
            // Specify the dimensions of the chart.
            const width = 2000;
            const height = 1200;

            // Specify the color scale.
            const color = d3.scaleOrdinal(d3.schemeCategory10);

            // The force simulation mutates links and nodes, so create a copy
            // so that re-evaluating this cell produces the same result.
            const links = data.links.map(d => ({...d}));
            const nodes = data.nodes.map(d => ({...d}));

            // Create a simulation with several forces.
            const simulation = d3.forceSimulation(nodes)
                .force("link", d3.forceLink(links).id(d => d.id))
                .force("charge", d3.forceManyBody())
                .force("center", d3.forceCenter(width / 2, height / 2))
                .on("tick", ticked);

            // Create the SVG container.
            const svg = d3.create("svg")
                .attr("width", width)
                .attr("height", height)
                .attr("viewBox", [0, 0, width, height])
                .attr("style", "max-width: 100%; height: auto;");

            // Add a line for each link, and a circle for each node.
            const link = svg.append("g")
                .attr("stroke", "#999")
                .attr("stroke-opacity", 0.6)
                .selectAll()
                .data(links)
                .join("line")
                .attr("stroke-width", d => Math.sqrt(d.value));

            const node = svg.append("g")
                .attr("stroke", "#fff")
                .attr("stroke-width", 1.5)
                .selectAll()
                .data(nodes)
                .join("circle")
                .attr("r", 5)
                .attr("fill", d => color(d.group));

            node.append("title")
                .text(d => d.id);

            // Add a drag behavior.
            node.call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));

            // Set the position attributes of links and nodes each time the simulation ticks.
            function ticked() {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                node
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y);
            }

            // Reheat the simulation when drag starts, and fix the subject position.
            function dragstarted(event) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                event.subject.fx = event.subject.x;
                event.subject.fy = event.subject.y;
            }

            // Update the subject (dragged node) position during drag.
            function dragged(event) {
                event.subject.fx = event.x;
                event.subject.fy = event.y;
            }

            // Restore the target alpha so the simulation cools after dragging ends.
            // Unfix the subject position now that it’s no longer being dragged.
            function dragended(event) {
                if (!event.active) simulation.alphaTarget(0);
                event.subject.fx = null;
                event.subject.fy = null;
            }

            // When this cell is re-run, stop the previous simulation. (This doesn’t
            // really matter since the target alpha is zero and the simulation will
            // stop naturally, but it’s a good practice.)
            //invalidation.then(() => simulation.stop());

            return svg.node();
            }
    </script>
</html>